"use strict";var t,e=this&&this.t||function(t,e,s,i){var n,a=arguments.length,r=3>a?e:null===i?i=Object.getOwnPropertyDescriptor(e,s):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(t,e,s,i);else for(var c=t.length-1;c>=0;c--)(n=t[c])&&(r=(3>a?n(r):a>3?n(e,s,r):n(e,s))||r);return a>3&&r&&Object.defineProperty(e,s,r),r},s=this&&this.i||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)};Object.defineProperty(exports,"o",{value:!0}),exports.RedisService=void 0;const i=require("@nestjs/common"),n=require("ioredis"),a=require("../constants/config");let r=t=class{constructor(){this.logger=new i.Logger(t.name),this.redisClient=null}async getClient(){if(this.redisClient)return this.redisClient;const t=a.config.redis.host??"localhost",e=a.config.redis.port??6379,s=a.config.redis.password??void 0,i=a.config.redis.db??3;return this.redisClient=new n.default({host:t,port:e,password:s,db:i,enableReadyCheck:!1,maxRetriesPerRequest:null,lazyConnect:!0}),this.redisClient.on("error",t=>{this.logger.error("Redis Client Error",t.stack||t.message)}),this.redisClient.on("connect",()=>{this.logger.log("Redis Client Connected")}),this.redisClient.on("ready",()=>{this.logger.log("Redis Client Ready")}),this.redisClient.on("close",()=>{this.logger.warn("Redis Client Connection Closed")}),this.redisClient.on("reconnecting",()=>{this.logger.log("Redis Client Reconnecting...")}),await this.redisClient.connect(),this.redisClient}async disconnect(){this.redisClient&&(await this.redisClient.disconnect(),this.redisClient=null,this.logger.log("Redis Client Disconnected"))}async onModuleDestroy(){await this.disconnect()}async get(t){return(await this.getClient()).get(t)}async set(t,e,s){const i=await this.getClient();if(s){const n=Math.ceil(s/1e3);return i.setex(t,n,e)}return i.set(t,e)}async setex(t,e,s){const i=await this.getClient(),n=Math.ceil(e/1e3);return i.setex(t,n,s)}async del(t){return(await this.getClient()).del(t)}async exists(t){return(await this.getClient()).exists(t)}async zadd(t,e,s){return(await this.getClient()).zadd(t,e,s)}async zrange(t,e,s){return(await this.getClient()).zrange(t,e,s)}async zrangebyscore(t,e,s,i){const n=await this.getClient();return i?n.zrangebyscore(t,e,s,"LIMIT",i.offset,i.count):n.zrangebyscore(t,e,s)}async zrem(t,...e){return(await this.getClient()).zrem(t,...e)}async sadd(t,...e){return(await this.getClient()).sadd(t,...e)}async sismember(t,e){return(await this.getClient()).sismember(t,e)}async hset(t,e,s){return(await this.getClient()).hset(t,e,s)}async hget(t,e){return(await this.getClient()).hget(t,e)}async hgetall(t){return(await this.getClient()).hgetall(t)}async expire(t,e){return(await this.getClient()).expire(t,e)}async setnx(t,e,s){const i=await this.getClient();if(s){const n=Math.ceil(s/1e3);return await i.set(t,e,"EX",n,"NX")}return await i.set(t,e,"NX")}};exports.RedisService=r,exports.RedisService=r=t=e([(0,i.Injectable)(),s("design:paramtypes",[])],r);