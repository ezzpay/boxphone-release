"use strict";var t,e=this&&this.t||function(t,e,i,s){var a,r=arguments.length,o=3>r?e:null===s?s=Object.getOwnPropertyDescriptor(e,i):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,i,s);else for(var n=t.length-1;n>=0;n--)(a=t[n])&&(o=(3>r?a(o):r>3?a(e,i,o):a(e,i))||o);return r>3&&o&&Object.defineProperty(e,i,o),o},i=this&&this.i||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)},s=this&&this.o||function(t,e){return function(i,s){e(i,s,t)}};Object.defineProperty(exports,"h",{value:!0}),exports.WithdrawalJobManagerService=void 0;const a=require("@nestjs/common"),r=require("@nestjs/schedule"),o=require("@nestjs/bull"),n=require("./withdrawal.service"),c=require("../device/device.service"),h=require("../device/device-lock.service"),d=require("../../common/modules/websocket/constants/websocket"),l=require("./withdrawal-errors");let u=t=class{constructor(e,i,s,r,o){this.withdrawalQueue=e,this.withdrawalService=i,this.deviceService=s,this.deviceLock=r,this.wsService=o,this.logger=new a.Logger(t.name),this.processingJobs=new Set,this.isInitialized=!1}async onModuleInit(){this.logger.log("WithdrawalJobManagerService initialized, waiting 5 seconds before starting..."),setTimeout(()=>{this.initializeJobProcessing()},5e3)}async initializeJobProcessing(){this.isInitialized||await this.startProcessing()}async startProcessing(){try{this.logger.log("Starting withdrawal job processing...");const t=await this.deviceService.getServiceStatus();if("active"!==t)return this.logger.log(`Service is ${t}, cannot start processing`),void 0;await this.pickAndProcessJobs(),this.isInitialized=!0}catch(t){this.logger.error("Error starting job processing: "+t.message,t.stack)}}async getAvailableDevices(){try{const t=await this.wsService.listDevices(),e=[];for(const i of t){const t=await this.deviceService.getDeviceConfig(i.udid);"active"===t?.status&&(await this.deviceLock.isLocked(i.udid)||e.push({udid:i.udid,config:t}))}return e}catch(t){return this.logger.error("Error getting available devices: "+t.message),[]}}async pickAndProcessJobs(t){try{const e=await this.deviceService.getServiceStatus();if("active"!==e)return this.logger.debug(`Service is ${e}, cannot pick jobs`),void 0;const i=await this.getAvailableDevices(),s=i.length;if(0>=s)return;const a=t?Math.min(t,s):s,[r,o]=await Promise.all([this.withdrawalQueue.getJobs(["waiting"],0,a-1),this.withdrawalQueue.getJobs(["delayed"],0,a-1)]),n=Date.now(),c=(o||[]).filter(t=>{const e=t.opts?.delay?t.opts.delay:0;return n>=e}),h=[...r||[],...c].sort((t,e)=>t.opts?.delay&&!e.opts?.delay?1:!t.opts?.delay&&e.opts?.delay?-1:0).slice(0,a);if(0===h.length)return;this.logger.log(`Found ${i.length} available devices. Picking ${h.length} jobs (${(r||[]).length} waiting, ${c.length} delayed ready).`);for(let t=0;t<h.length;t++){const e=h[t],s=i[t];if(this.processingJobs.has(e?.id))continue;const a=`withdraw:${e.data.withdrawalId}:${s.udid}`;await this.deviceLock.acquireLock(s.udid,"transfer",a,6e5)?this.processJob(e,s.udid).catch(t=>{this.deviceLock.releaseLock(s.udid).catch(()=>{}),this.logger.error(`Error processing job ${e?.id}: ${t.message}`,t.stack)}):this.logger.warn(`Device ${s.udid} was locked after assignment, skipping job ${e.id}`)}}catch(t){this.logger.error("Error picking jobs: "+t.message,t.stack)}}async processJob(t,e){const{data:i}=t;if(!i||!i.withdrawalId){this.logger.error("Invalid withdrawal data in job "+t.id);try{await t.remove()}catch(e){this.logger.warn(`Could not remove invalid job ${t.id}: ${e.message}`)}return}const{withdrawalId:s}=i;this.processingJobs.add(t.id),this.logger.log(`Processing withdrawal request: ${s} (job ${t.id}) on device ${e}`),this.logger.debug("Job Data Keys: "+Object.keys(i).join(", ")),this.logger.debug(`Job Data _id: ${i.l}, type: ${typeof i.l}`),this.logger.debug("Job Data withdrawalId: "+i.withdrawalId);try{if(await this.withdrawalService.processWithdrawal(i,e))try{await t.remove(),this.logger.log(`Successfully processed and removed withdrawal ${s} from queue`)}catch(e){this.logger.warn(`Could not remove completed job ${t.id}: ${e.message}`)}else{const e="Process returned false",i=(0,l.classifyError)(e);await this.handleJobFailure(t,s,e,i)}}catch(e){let i;this.logger.error(`Error processing withdrawal ${s}: ${e.message}`,e.stack),i=e instanceof l.WithdrawalProcessingError?e.errorType:(0,l.classifyError)(e.message,e),await this.handleJobFailure(t,s,e.message,i)}finally{this.processingJobs.delete(t.id),setTimeout(()=>{this.pickAndProcessJobs(1).catch(t=>this.logger.error("Error triggering next job pick: "+t.message))},1e3)}}async handleJobFailure(t,e,i,s=l.ErrorType.UNKNOWN){let a;switch(s){case l.ErrorType.TEMPORARY:a=5;break;case l.ErrorType.PERMANENT:a=2;break;default:a=3}const r=t.data.manualRetryCount||0;if(this.logger.warn(`Job ${t.id} (Withdrawal ${e}) failed. Reason: ${i}. Error Type: ${s}. Retry attempt: ${r}/${a}`),a>r)try{await t.update({...t.data,manualRetryCount:r+1,lastErrorType:s,lastErrorReason:i});const e=Date.now()+3e4;await t.moveToDelayed(e),this.logger.log(`Job ${t.id} moved to delayed queue until ${new Date(e).toISOString()} (Error Type: ${s}, Retry ${r+1}/${a})`)}catch(e){this.logger.error(`Failed to queue retry for job ${t.id}: ${e.message}`),await t.moveToFailed({message:"Retry failed: "+e.message})}else{this.logger.error(`Job ${t.id} exceeded max retries (${a}) for error type ${s}. Marking as failed permanently.`);try{await t.moveToFailed({message:`Max retries (${a}) exceeded for ${s} error: ${i}`})}catch(e){this.logger.warn(`Could not move job ${t.id} to failed: ${e.message}`)}}}async triggerPickJobs(t=1){await this.pickAndProcessJobs(t)}async getQueueStats(){const[t,e,i,s,a,r,o]=await Promise.all([this.withdrawalQueue.getWaitingCount(),this.withdrawalQueue.getDelayedCount(),this.withdrawalQueue.getActiveCount(),this.withdrawalQueue.getCompletedCount(),this.withdrawalQueue.getFailedCount(),this.getAvailableDevices(),this.deviceService.getServiceStatus()]);return{serviceStatus:o,activeDevices:r.length,processingJobs:this.processingJobs.size,isInitialized:this.isInitialized,queue:{waiting:t,delayed:e,active:i,completed:s,failed:a,total:t+e+i}}}async debugQueue(){const t=await this.getQueueStats(),[e,i]=await Promise.all([this.withdrawalQueue.getJobs(["waiting"],0,9),this.withdrawalQueue.getJobs(["delayed"],0,9)]);return{...t,sampleWaitingJobs:e.map(t=>({id:t.id,data:t.data,opts:t.opts,manualRetryCount:t.data.manualRetryCount})),sampleDelayedJobs:i.map(t=>({id:t.id,data:t.data,opts:t.opts,manualRetryCount:t.data.manualRetryCount}))}}async periodicJobPicking(){await this.pickAndProcessJobs()}};exports.WithdrawalJobManagerService=u,e([(0,r.Cron)("*/10 * * * * *"),i("design:type",Function),i("design:paramtypes",[]),i("design:returntype",Promise)],u.prototype,"periodicJobPicking",null),exports.WithdrawalJobManagerService=u=t=e([(0,a.Injectable)(),s(0,(0,o.InjectQueue)("wda-request")),s(4,(0,a.Inject)(d.WEBSOCKET_SERVICE)),i("design:paramtypes",[Object,n.WithdrawalService,c.DeviceService,h.DeviceLockService,Object])],u);