"use strict";var t,i=this&&this.t||function(t,i,e,s){var a,r=arguments.length,o=3>r?i:null===s?s=Object.getOwnPropertyDescriptor(i,e):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,i,e,s);else for(var n=t.length-1;n>=0;n--)(a=t[n])&&(o=(3>r?a(o):r>3?a(i,e,o):a(i,e))||o);return r>3&&o&&Object.defineProperty(i,e,o),o},e=this&&this.i||function(t,i){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,i)},s=this&&this.o||function(t,i){return function(e,s){i(e,s,t)}};Object.defineProperty(exports,"h",{value:!0}),exports.WithdrawalJobManagerService=void 0;const a=require("@nestjs/common"),r=require("@nestjs/schedule"),o=require("@nestjs/bull"),n=require("./withdrawal.service"),c=require("../device/device.service"),h=require("../device/device-lock.service"),l=require("../../common/modules/websocket/constants/websocket"),d=require("./withdrawal-errors"),u=require("lodash");let w=t=class{constructor(i,e,s,r,o){this.withdrawalQueue=i,this.withdrawalService=e,this.deviceService=s,this.deviceLock=r,this.wsService=o,this.logger=new a.Logger(t.name),this.processingJobs=new Set,this.isInitialized=!1}async onModuleInit(){this.logger.log("WithdrawalJobManagerService initialized, waiting 5 seconds before starting..."),setTimeout(()=>{this.initializeJobProcessing()},5e3)}async initializeJobProcessing(){this.isInitialized||await this.startProcessing()}async startProcessing(){try{this.logger.log("Starting withdrawal job processing..."),await this.pickAndProcessJobs(),this.isInitialized=!0}catch(t){this.logger.error("Error starting job processing: "+t.message,t.stack)}}async getAvailableDevices(){try{const t=await this.wsService.listDevices(),i=[];for(const e of t){const t=await this.deviceService.getDeviceConfig(e.udid);"active"===t?.status&&(await this.deviceLock.isLocked(e.udid)||i.push({udid:e.udid,config:t}))}return i}catch(t){return this.logger.error("Error getting available devices: "+t.message),[]}}async pickAndProcessJobs(t){try{const i=await this.deviceService.getServiceStatus();if("active"!==i)return this.logger.debug(`Service is ${i}, cannot pick jobs`),void 0;const e=await this.getAvailableDevices(),s=e.length;if(0>=s)return;const a=t?Math.min(t,s):s,r=await this.withdrawalQueue.getJobs(["waiting"],0,a-1);if(0===r.length)return;this.logger.log(`Found ${e.length} available devices. Picking ${r.length} jobs (${(r||[]).length} waiting.`);for(let t=0;t<r.length;t++){const i=r[t],s=e[t];if(this.logger.debug("Processing jobs: "+JSON.stringify(this.processingJobs)),this.processingJobs.has(i.id))continue;const a=`withdraw:${i.data.withdrawalId}:${s.udid}`;await this.deviceLock.acquireLock(s.udid,"transfer",a,220800)?this.processJob(i,s.udid).catch(t=>{this.deviceLock.releaseLock(s.udid).catch(()=>{}),this.logger.error(`Error processing job ${i.id}: ${t.message}`,t.stack)}):this.logger.warn(`Device ${s.udid} was locked after assignment, skipping job ${i.id}`)}}catch(t){this.logger.error("Error picking jobs: "+t.message,t.stack)}}async processJob(t,i){const e=(0,u.cloneDeep)(t.data),{withdrawalId:s}=e;try{this.logger.log(`Successfully processed and removed withdrawal ${s} from queue`),await t.remove()}catch(i){this.logger.warn(`Could not remove completed job ${t.id}: ${i.message}`)}e&&e.withdrawalId||this.logger.error("Invalid withdrawal data in job "+t.id),this.processingJobs.add(t.id);try{await this.withdrawalService.processWithdrawal(e,i)}catch(t){let i;this.logger.error(`Error processing withdrawal ${s}: ${t.message}`,t.stack),i=t instanceof d.WithdrawalProcessingError?t.errorType:(0,d.classifyError)(t.message,t),await this.handleJobFailure(e,t.message,i)}finally{this.processingJobs.delete(t.id)}}async handleJobFailure(t,i,e=d.ErrorType.UNKNOWN){const s=t.manualRetryCount??0;if(this.logger.warn(`Withdrawal ${t.withdrawalId} failed. Reason: ${i}. Error Type: ${e}. Retry attempt: ${s}/3`),3>s){if(e===d.ErrorType.UNKNOWN)return;await this.withdrawalQueue.add("process-withdrawal-request",{...t,manualRetryCount:s+1,lastErrorType:e,lastErrorReason:i},{attempts:0,removeOnComplete:!1,removeOnFail:!1,jobId:"withdrawal-request-"+t.withdrawalId,priority:0,delay:3e4})}else this.logger.warn(`Max retries (3) exceeded for withdrawal ${t.withdrawalId}: ${e} error: ${i}`)}async triggerPickJobs(t=1){await this.pickAndProcessJobs(t)}async getQueueStats(){const[t,i,e,s,a,r,o]=await Promise.all([this.withdrawalQueue.getWaitingCount(),this.withdrawalQueue.getDelayedCount(),this.withdrawalQueue.getActiveCount(),this.withdrawalQueue.getCompletedCount(),this.withdrawalQueue.getFailedCount(),this.getAvailableDevices(),this.deviceService.getServiceStatus()]);return{serviceStatus:o,activeDevices:r.length,processingJobs:this.processingJobs.size,isInitialized:this.isInitialized,queue:{waiting:t,delayed:i,active:e,completed:s,failed:a,total:t+i+e}}}async debugQueue(){const t=await this.getQueueStats(),[i,e]=await Promise.all([this.withdrawalQueue.getJobs(["waiting"],0,9),this.withdrawalQueue.getJobs(["delayed"],0,9)]);return{...t,sampleWaitingJobs:i.map(t=>({id:t.id,data:t.data,opts:t.opts,manualRetryCount:t.data.manualRetryCount})),sampleDelayedJobs:e.map(t=>({id:t.id,data:t.data,opts:t.opts,manualRetryCount:t.data.manualRetryCount}))}}async periodicJobPicking(){this.logger.log("Periodic job picking..."),await this.pickAndProcessJobs()}};exports.WithdrawalJobManagerService=w,i([(0,r.Cron)("*/5 * * * * *"),e("design:type",Function),e("design:paramtypes",[]),e("design:returntype",Promise)],w.prototype,"periodicJobPicking",null),exports.WithdrawalJobManagerService=w=t=i([(0,a.Injectable)(),s(0,(0,o.InjectQueue)("wda-request")),s(4,(0,a.Inject)(l.WEBSOCKET_SERVICE)),e("design:paramtypes",[Object,n.WithdrawalService,c.DeviceService,h.DeviceLockService,Object])],w);