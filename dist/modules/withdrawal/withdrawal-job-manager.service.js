"use strict";var t,e=this&&this.t||function(t,e,i,s){var a,r=arguments.length,o=3>r?e:null===s?s=Object.getOwnPropertyDescriptor(e,i):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,i,s);else for(var c=t.length-1;c>=0;c--)(a=t[c])&&(o=(3>r?a(o):r>3?a(e,i,o):a(e,i))||o);return r>3&&o&&Object.defineProperty(e,i,o),o},i=this&&this.i||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)},s=this&&this.o||function(t,e){return function(i,s){e(i,s,t)}};Object.defineProperty(exports,"h",{value:!0}),exports.WithdrawalJobManagerService=void 0;const a=require("@nestjs/common"),r=require("@nestjs/schedule"),o=require("@nestjs/bull"),c=require("./withdrawal.service"),n=require("../device/device.service"),h=require("../device/device-lock.service"),l=require("../../common/modules/websocket/constants/websocket"),d=require("./withdrawal-errors");let u=t=class{constructor(e,i,s,r,o){this.withdrawalQueue=e,this.withdrawalService=i,this.deviceService=s,this.deviceLock=r,this.wsService=o,this.logger=new a.Logger(t.name),this.processingJobs=new Set,this.isInitialized=!1}async onModuleInit(){this.logger.log("WithdrawalJobManagerService initialized, waiting 5 seconds before starting..."),setTimeout(()=>{this.initializeJobProcessing()},5e3)}async initializeJobProcessing(){if(!this.isInitialized)try{await this.startProcessing()}catch(t){this.logger.error("Error starting job processing: "+t.message,t.stack)}}async startProcessing(){try{this.logger.log("Starting withdrawal job processing...");const t=await this.deviceService.getServiceStatus();if("active"!==t)return this.logger.log(`Service is ${t}, cannot start processing`),void 0;await this.pickAndProcessJobs(),this.isInitialized=!0}catch(t){this.logger.error("Error starting job processing: "+t.message,t.stack)}}async getAvailableDevices(){const t=await this.wsService.listDevices(),e=[];for(const i of t){const t=await this.deviceService.getDeviceConfig(i.udid);"active"===t?.status&&(await this.deviceLock.isLocked(i.udid)||e.push({udid:i.udid,config:t}))}return e}async pickAndProcessJobs(t){try{const e=await this.deviceService.getServiceStatus();if("active"!==e)return this.logger.debug(`Service is ${e}, cannot pick jobs`),void 0;let i;try{i=await this.getAvailableDevices()}catch(t){this.logger.error("Error getting available devices: "+t.message),i=[]}const s=i.length;if(0>=s)return;const a=t?Math.min(t,s):s,[r,o]=await Promise.all([this.withdrawalQueue.getJobs(["waiting"],0,a-1),this.withdrawalQueue.getJobs(["delayed"],0,a-1)]),c=Date.now(),n=(o||[]).filter(t=>{const e=t.opts?.delay?t.opts.delay:0;return c>=e}),h=[...r||[],...n].sort((t,e)=>t.opts?.delay&&!e.opts?.delay?1:!t.opts?.delay&&e.opts?.delay?-1:0).slice(0,a);if(0===h.length)return;this.logger.log(`Found ${i.length} available devices. Picking ${h.length} jobs (${(r||[]).length} waiting, ${n.length} delayed ready).`);for(let t=0;t<h.length;t++){const e=h[t],s=i[t];if(this.processingJobs.has(e?.id))continue;const a=`withdraw:${e.data.withdrawalId}:${s.udid}`;if(await this.deviceLock.acquireLock(s.udid,"transfer",a,6e5))try{await this.processJob(e,s.udid)}catch(t){try{await this.deviceLock.releaseLock(s.udid)}catch(t){this.logger.error(`Error releasing lock for device ${s.udid}: ${t.message}`)}this.logger.error(`Error processing job ${e?.id}: ${t.message}`,t.stack)}else this.logger.warn(`Device ${s.udid} was locked after assignment, skipping job ${e.id}`)}}catch(t){this.logger.error("Error picking jobs: "+t.message,t.stack)}}async processJob(t,e){const{data:i}=t;if(!i||!i.withdrawalId)return this.logger.error("Invalid withdrawal data in job "+t.id),await t.remove(),void 0;const{withdrawalId:s}=i;this.processingJobs.add(t.id);try{if(this.logger.log(`Processing withdrawal request: ${s} (job ${t.id}) on device ${e}`),this.logger.debug("Job Data Keys: "+Object.keys(i).join(", ")),this.logger.debug(`Job Data Dot Access ._id: ${i.l}, type: ${typeof i.l}`),this.logger.debug(`Job Data Bracket Access ['_id']: ${i.l}, type: ${typeof i.l}`),this.logger.debug("Job Data Full Object: "+JSON.stringify(i)),this.logger.debug("Job Data withdrawalId: "+i.withdrawalId),await this.withdrawalService.processWithdrawal(i,e))try{await t.remove(),this.logger.log(`Successfully processed and removed withdrawal ${s} from queue`)}catch(e){this.logger.warn(`Could not remove completed job ${t.id}: ${e.message}`)}else{const e="Process returned false",i=(0,d.classifyError)(e);await this.handleJobFailure(t,s,e,i)}}catch(e){let i;this.logger.error(`Error processing withdrawal ${s}: ${e.message}`,e.stack),i=e instanceof d.WithdrawalProcessingError?e.errorType:(0,d.classifyError)(e.message,e);try{await this.handleJobFailure(t,s,e.message,i)}catch(t){this.logger.error(`Error handling job failure for ${s}: ${t.message}`)}}finally{try{await this.deviceLock.releaseLock(e),this.logger.debug(`Released lock for device ${e} after processing withdrawal ${s}`)}catch(t){this.logger.error(`Error releasing lock for device ${e}: ${t.message}`)}this.processingJobs.delete(t.id),setTimeout(()=>{this.pickAndProcessJobs(1).catch(t=>this.logger.error("Error triggering next job pick: "+t.message))},1e3)}}async handleJobFailure(t,e,i,s=d.ErrorType.UNKNOWN){let a;switch(s){case d.ErrorType.TEMPORARY:a=5;break;case d.ErrorType.PERMANENT:a=2;break;default:a=3}const r=t.data.manualRetryCount||0;if(this.logger.warn(`Job ${t.id} (Withdrawal ${e}) failed. Reason: ${i}. Error Type: ${s}. Retry attempt: ${r}/${a}`),a>r)try{await t.update({...t.data,manualRetryCount:r+1,lastErrorType:s,lastErrorReason:i});const e=Date.now()+3e4;await t.moveToDelayed(e),this.logger.log(`Job ${t.id} moved to delayed queue until ${new Date(e).toISOString()} (Error Type: ${s}, Retry ${r+1}/${a})`)}catch(e){this.logger.error(`Failed to queue retry for job ${t.id}: ${e.message}`);try{await t.moveToFailed({message:"Retry failed: "+e.message})}catch(e){this.logger.error(`Failed to move job ${t.id} to failed state: ${e.message}`)}}else{this.logger.error(`Job ${t.id} exceeded max retries (${a}) for error type ${s}. Marking as failed permanently.`);try{await t.moveToFailed({message:`Max retries (${a}) exceeded for ${s} error: ${i}`})}catch(e){this.logger.warn(`Could not move job ${t.id} to failed: ${e.message}`)}}}async triggerPickJobs(t=1){try{await this.pickAndProcessJobs(t)}catch(t){this.logger.error("Error triggering job pick: "+t.message,t.stack)}}async getQueueStats(){let t=[];try{t=await this.getAvailableDevices()}catch(t){this.logger.error("Error getting available devices in getQueueStats: "+t.message)}const[e,i,s,a,r,o]=await Promise.all([this.withdrawalQueue.getWaitingCount(),this.withdrawalQueue.getDelayedCount(),this.withdrawalQueue.getActiveCount(),this.withdrawalQueue.getCompletedCount(),this.withdrawalQueue.getFailedCount(),this.deviceService.getServiceStatus()]);return{serviceStatus:o,activeDevices:t.length,processingJobs:this.processingJobs.size,isInitialized:this.isInitialized,queue:{waiting:e,delayed:i,active:s,completed:a,failed:r,total:e+i+s}}}async debugQueue(){const t=await this.getQueueStats(),[e,i]=await Promise.all([this.withdrawalQueue.getJobs(["waiting"],0,9),this.withdrawalQueue.getJobs(["delayed"],0,9)]);return{...t,sampleWaitingJobs:e.map(t=>({id:t.id,data:t.data,opts:t.opts,manualRetryCount:t.data.manualRetryCount})),sampleDelayedJobs:i.map(t=>({id:t.id,data:t.data,opts:t.opts,manualRetryCount:t.data.manualRetryCount}))}}async periodicJobPicking(){try{await this.pickAndProcessJobs()}catch(t){this.logger.error("Error in periodic job picking: "+t.message,t.stack)}}};exports.WithdrawalJobManagerService=u,e([(0,r.Cron)("*/10 * * * * *"),i("design:type",Function),i("design:paramtypes",[]),i("design:returntype",Promise)],u.prototype,"periodicJobPicking",null),exports.WithdrawalJobManagerService=u=t=e([(0,a.Injectable)(),s(0,(0,o.InjectQueue)("wda-request")),s(4,(0,a.Inject)(l.WEBSOCKET_SERVICE)),i("design:paramtypes",[Object,c.WithdrawalService,n.DeviceService,h.DeviceLockService,Object])],u);