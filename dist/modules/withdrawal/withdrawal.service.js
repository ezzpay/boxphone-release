"use strict";var t,e=this&&this.t||function(t,e,i,s){var a,r=arguments.length,o=3>r?e:null===s?s=Object.getOwnPropertyDescriptor(e,i):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,i,s);else for(var c=t.length-1;c>=0;c--)(a=t[c])&&(o=(3>r?a(o):r>3?a(e,i,o):a(e,i))||o);return r>3&&o&&Object.defineProperty(e,i,o),o},i=this&&this.i||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)},s=this&&this.o||function(t,e){return function(i,s){e(i,s,t)}};Object.defineProperty(exports,"h",{value:!0}),exports.WithdrawalService=void 0;const a=require("@nestjs/common"),r=require("../../common/services/ezpay-be-client.service"),o=require("../bank/bank.service"),c=require("../device/device.service"),n=require("../device/device-lock.service"),h=require("../../common/services/redis.service"),d=require("../../common/modules/websocket/constants/websocket"),w=require("./withdrawal-errors");let l=t=class{constructor(e,i,s,r,o,c){this.ezpayBeClient=e,this.wsService=i,this.bankService=s,this.deviceService=r,this.deviceLock=o,this.redisService=c,this.logger=new a.Logger(t.name),this.REDIS_PROCESSED_PREFIX="withdrawal:processed:",this.PROCESSING_TTL=36e5,this.COMPLETED_TTL=864e5}async checkIfProcessed(t){try{const e=`${this.REDIS_PROCESSED_PREFIX}${t}`,i=await this.redisService.get(e);return"completed"===i?(this.logger.warn(`Withdrawal ${t} already completed`),!0):"processing"===i&&(this.logger.warn(`Withdrawal ${t} is being processed by another instance`),!0)}catch(e){return this.logger.error(`Error checking processed status for ${t}: ${e.message}`),!1}}async markAsProcessing(t){try{const e=`${this.REDIS_PROCESSED_PREFIX}${t}`;return"OK"===await this.redisService.setnx(e,"processing",this.PROCESSING_TTL)?(this.logger.debug(`Marked withdrawal ${t} as processing`),!0):(this.logger.warn(`Withdrawal ${t} is already being processed by another instance`),!1)}catch(e){return this.logger.error(`Error marking withdrawal ${t} as processing: ${e.message}`),!0}}async markAsCompleted(t){try{const e=`${this.REDIS_PROCESSED_PREFIX}${t}`;await this.redisService.set(e,"completed",this.COMPLETED_TTL),this.logger.log(`Marked withdrawal ${t} as completed`)}catch(e){this.logger.error(`Error marking withdrawal ${t} as completed: ${e.message}`)}}async markAsFailed(t){try{const e=`${this.REDIS_PROCESSED_PREFIX}${t}`;await this.redisService.del(e),this.logger.log(`Marked withdrawal ${t} as failed (removed from processed list)`)}catch(e){this.logger.error(`Error marking withdrawal ${t} as failed: ${e.message}`)}}async processWithdrawal(t,e){const{withdrawalId:i,bankCode:s,amount:a}=t;if(await this.checkIfProcessed(i))return this.logger.warn(`Withdrawal ${i} already processed or being processed, skipping`),void 0;if(!await this.markAsProcessing(i)){const t=`Withdrawal ${i} is being processed by another instance`;throw this.logger.warn(t),new w.WithdrawalProcessingError(t,w.ErrorType.TEMPORARY,i)}let r=!0,o=!1;try{this.logger.log(`Processing withdrawal: ${i} for bank: ${s}, amount: ${a} on assigned device: ${e}`);const c=await this.deviceService.getDeviceConfig(e);if(!c||"active"!==c.status){const t=`Assigned device ${e} is not active or not found`;throw this.logger.error(t),await this.markAsFailed(i),r=!1,new w.WithdrawalProcessingError(t,w.ErrorType.TEMPORARY,i)}if(c.availableAmount<a){const t=`Assigned device ${e} has insufficient amount. Available: ${c.availableAmount}, Required: ${a}`;throw this.logger.error(t),await this.markAsFailed(i),r=!1,new w.WithdrawalProcessingError(t,w.ErrorType.TEMPORARY,i)}if(!await this.bankService.isSessionValid(e,c.bankCode)){const t=`Assigned device ${e} does not have valid session for bank ${c.bankCode}`;throw this.logger.error(t),await this.markAsFailed(i),r=!1,new w.WithdrawalProcessingError(t,w.ErrorType.TEMPORARY,i)}const n=e;await this.bankService.executeTransfer(t,n,c.bankCode),this.deviceService.deductDeviceAmount(n,a).catch(()=>{}),await this.markAsCompleted(i),o=!0,r=!1;const h=await this.bankService.analyzeTransferBill(c.bankCode,t);await this.notifyEzpayBe(t,h,c),"unknown"===h.analyzedStatus&&await this.bankService.login(c.bankCode,n,!0),this.logger.log("Successfully processed withdrawal: "+i)}catch(t){if(t instanceof w.WithdrawalProcessingError)throw t;throw this.logger.error(`Error processing withdrawal ${i}: ${t.message}`,t.stack),await this.markAsFailed(i),r=!1,new w.WithdrawalProcessingError(t.message||"Unknown error",w.ErrorType.UNKNOWN,i)}finally{await this.deviceLock.releaseLock(e),r&&!o&&await this.markAsFailed(i)}}async notifyEzpayBe(t,e,i){try{await this.ezpayBeClient.updateWithdrawalStatus(t.l,{analyzedStatus:e.analyzedStatus,sourceAccountNo:i.accountNo,sourceBankCode:i.bankCode,receipt:e.rawPath})||this.logger.error(`Failed to notify ezpay-be about withdrawal ${t.l} status ${e.analyzedStatus}`)}catch(e){throw this.logger.error(`Error notifying ezpay-be about withdrawal ${t.l}: ${e.message}`),e}}};exports.WithdrawalService=l,exports.WithdrawalService=l=t=e([(0,a.Injectable)(),s(1,(0,a.Inject)(d.WEBSOCKET_SERVICE)),s(3,(0,a.Inject)((0,a.forwardRef)(()=>c.DeviceService))),i("design:paramtypes",[r.EzpayBeClientService,Object,o.BankService,c.DeviceService,n.DeviceLockService,h.RedisService])],l);