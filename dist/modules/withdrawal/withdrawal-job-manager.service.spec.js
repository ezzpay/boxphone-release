"use strict";Object.defineProperty(exports,"t",{value:!0});const e=require("@nestjs/testing"),t=require("@nestjs/bull"),i=require("./withdrawal-job-manager.service"),s=require("./withdrawal.service"),a=require("../device/device.service"),c=require("../device/device-lock.service"),d=require("../../common/modules/websocket/constants/websocket"),o=require("./withdrawal-errors");describe("WithdrawalJobManagerService",()=>{let v,n,r,u,l,p;const w={i:"test-id",withdrawalId:"WDR_123",withdrawalCode:"WDR_CODE_123",bankCode:"ACB",beneficiaryAccountNo:"1234567890",beneficiaryName:"Test User",amount:1e6,status:"pending",description:"Test withdrawal",createdAt:(new Date).toISOString()},b=(e,t=1,i={})=>({id:t,data:e,remove:jest.fn().mockResolvedValue(void 0),update:jest.fn().mockResolvedValue(void 0),moveToDelayed:jest.fn().mockResolvedValue(void 0),moveToFailed:jest.fn().mockResolvedValue(void 0),opts:i});beforeEach(async()=>{const o={getJobs:jest.fn(),getWaitingCount:jest.fn().mockResolvedValue(0),getDelayedCount:jest.fn().mockResolvedValue(0),getActiveCount:jest.fn().mockResolvedValue(0),getCompletedCount:jest.fn().mockResolvedValue(0),getFailedCount:jest.fn().mockResolvedValue(0)},w={processWithdrawal:jest.fn(),notifyEzpayBe:jest.fn()},b={getServiceStatus:jest.fn(),getDeviceConfig:jest.fn()},j={isLocked:jest.fn(),acquireLock:jest.fn(),releaseLock:jest.fn()},m={listDevices:jest.fn()},x=await e.Test.createTestingModule({providers:[i.WithdrawalJobManagerService,{provide:(0,t.getQueueToken)("wda-request"),useValue:o},{provide:s.WithdrawalService,useValue:w},{provide:a.DeviceService,useValue:b},{provide:c.DeviceLockService,useValue:j},{provide:d.WEBSOCKET_SERVICE,useValue:m}]}).compile();v=x.get(i.WithdrawalJobManagerService),n=x.get((0,t.getQueueToken)("wda-request")),r=x.get(s.WithdrawalService),u=x.get(a.DeviceService),l=x.get(c.DeviceLockService),p=x.get(d.WEBSOCKET_SERVICE)}),afterEach(()=>{jest.clearAllMocks()}),describe("startProcessing",()=>{it("should pick jobs when service is active and devices are available",async()=>{u.getServiceStatus.mockResolvedValue("active"),p.listDevices.mockResolvedValue([{udid:"device1"},{udid:"device2"},{udid:"device3"}]),u.getDeviceConfig.mockResolvedValueOnce({deviceId:"device1",status:"active",availableAmount:1e6}).mockResolvedValueOnce({deviceId:"device2",status:"active",availableAmount:1e6}).mockResolvedValueOnce({deviceId:"device3",status:"active",availableAmount:1e6}).mockResolvedValueOnce({deviceId:"device1",status:"active",availableAmount:1e6}).mockResolvedValueOnce({deviceId:"device2",status:"active",availableAmount:1e6}).mockResolvedValueOnce({deviceId:"device3",status:"active",availableAmount:1e6}),l.isLocked.mockResolvedValueOnce(!1).mockResolvedValueOnce(!1).mockResolvedValueOnce(!1).mockResolvedValueOnce(!1).mockResolvedValueOnce(!1).mockResolvedValueOnce(!1),l.acquireLock.mockResolvedValue(!0);const e=b(w,1);n.getJobs.mockResolvedValueOnce([e]).mockResolvedValueOnce([]),r.processWithdrawal.mockResolvedValue(!0),await v.startProcessing(),await new Promise(e=>setTimeout(e,200)),expect(u.getServiceStatus).toHaveBeenCalled(),expect(p.listDevices).toHaveBeenCalled(),expect(n.getJobs).toHaveBeenCalled(),expect(l.acquireLock).toHaveBeenCalled()}),it("should not pick jobs when service is inactive",async()=>{u.getServiceStatus.mockResolvedValue("inactive"),await v.startProcessing(),expect(u.getServiceStatus).toHaveBeenCalled(),expect(p.listDevices).not.toHaveBeenCalled(),expect(n.getJobs).not.toHaveBeenCalled()}),it("should not pick jobs when no active devices available",async()=>{u.getServiceStatus.mockResolvedValue("active"),p.listDevices.mockResolvedValue([]),await v.startProcessing(),expect(u.getServiceStatus).toHaveBeenCalled(),expect(p.listDevices).toHaveBeenCalled(),expect(n.getJobs).not.toHaveBeenCalled()}),it("should not pick jobs when all device slots are busy",async()=>{u.getServiceStatus.mockResolvedValue("active"),p.listDevices.mockResolvedValue([{udid:"device1"}]),u.getDeviceConfig.mockResolvedValue({deviceId:"device1",status:"active",availableAmount:1e6}),l.isLocked.mockResolvedValue(!0),await v.startProcessing(),expect(u.getServiceStatus).toHaveBeenCalled(),expect(n.getJobs).not.toHaveBeenCalled()})}),describe("pickAndProcessJobs",()=>{it("should pick and process jobs when service is active",async()=>{u.getServiceStatus.mockResolvedValue("active"),p.listDevices.mockResolvedValue([{udid:"device1"},{udid:"device2"}]),u.getDeviceConfig.mockResolvedValueOnce({deviceId:"device1",status:"active",availableAmount:1e6}).mockResolvedValueOnce({deviceId:"device2",status:"active",availableAmount:1e6}),l.isLocked.mockResolvedValueOnce(!1).mockResolvedValueOnce(!1),l.acquireLock.mockResolvedValue(!0);const e=b(w,1);n.getJobs.mockResolvedValueOnce([e]).mockResolvedValueOnce([]),r.processWithdrawal.mockResolvedValue(!0),await v.pickAndProcessJobs(2),expect(u.getServiceStatus).toHaveBeenCalled(),expect(n.getJobs).toHaveBeenCalledWith(["waiting"],0,1),expect(n.getJobs).toHaveBeenCalledWith(["delayed"],0,1),await new Promise(e=>setTimeout(e,1500)),expect(r.processWithdrawal).toHaveBeenCalledWith(w,"device1")}),it("should not pick jobs when service is inactive",async()=>{u.getServiceStatus.mockResolvedValue("inactive"),await v.pickAndProcessJobs(1),expect(u.getServiceStatus).toHaveBeenCalled(),expect(n.getJobs).not.toHaveBeenCalled()}),it("should not pick more jobs than available device slots",async()=>{u.getServiceStatus.mockResolvedValue("active"),p.listDevices.mockResolvedValue([{udid:"device1"}]),u.getDeviceConfig.mockResolvedValue({deviceId:"device1",status:"active",availableAmount:1e6}),l.isLocked.mockResolvedValue(!0),await v.pickAndProcessJobs(10),expect(u.getServiceStatus).toHaveBeenCalled(),expect(n.getJobs).not.toHaveBeenCalled()}),it("should not pick jobs when no waiting jobs available",async()=>{u.getServiceStatus.mockResolvedValue("active"),p.listDevices.mockResolvedValue([{udid:"device1"}]),u.getDeviceConfig.mockResolvedValue({deviceId:"device1",status:"active",availableAmount:1e6}),l.isLocked.mockResolvedValue(!1),n.getJobs.mockResolvedValueOnce([]).mockResolvedValueOnce([]),await v.pickAndProcessJobs(1),expect(n.getJobs).toHaveBeenCalled(),expect(r.processWithdrawal).not.toHaveBeenCalled()})}),describe("processJob",()=>{it("should process job successfully and remove it from queue",async()=>{const e=b(w,1);r.processWithdrawal.mockResolvedValue(!0);const t=jest.spyOn(v,"pickAndProcessJobs").mockResolvedValue(void 0);await v.processJob(e,"device1"),expect(r.processWithdrawal).toHaveBeenCalledWith(w,"device1"),expect(e.remove).toHaveBeenCalled(),await new Promise(e=>setTimeout(e,1500)),expect(t).toHaveBeenCalledWith(1),t.mockRestore()}),it("should handle job failure and retry when processing fails",async()=>{const e=b(w,1);r.processWithdrawal.mockResolvedValue(!1);const t=jest.spyOn(v,"pickAndProcessJobs").mockResolvedValue(void 0);await v.processJob(e,"device1"),expect(r.processWithdrawal).toHaveBeenCalledWith(w,"device1"),expect(e.update).toHaveBeenCalled(),expect(e.moveToDelayed).toHaveBeenCalled(),await new Promise(e=>setTimeout(e,1500)),expect(t).toHaveBeenCalledWith(1),t.mockRestore()}),it("should handle exception during processing and retry",async()=>{const e=b(w,1),t=new o.WithdrawalProcessingError("Processing error",o.ErrorType.TEMPORARY,"WDR_123");r.processWithdrawal.mockRejectedValue(t);const i=jest.spyOn(v,"pickAndProcessJobs").mockResolvedValue(void 0);await v.processJob(e,"device1"),expect(r.processWithdrawal).toHaveBeenCalledWith(w,"device1"),expect(e.update).toHaveBeenCalled(),expect(e.moveToDelayed).toHaveBeenCalled(),await new Promise(e=>setTimeout(e,1500)),expect(i).toHaveBeenCalledWith(1),i.mockRestore()}),it("should remove invalid job when withdrawal data is missing",async()=>{const e=b(null,1);await v.processJob(e),expect(r.processWithdrawal).not.toHaveBeenCalled(),expect(e.remove).toHaveBeenCalled()}),it("should handle job.remove() errors gracefully",async()=>{const e=b(w,1);e.remove.mockRejectedValue(Error("Could not remove job")),r.processWithdrawal.mockResolvedValue(!0);const t=jest.spyOn(v,"pickAndProcessJobs").mockResolvedValue(void 0);await v.processJob(e),expect(r.processWithdrawal).toHaveBeenCalled(),expect(e.remove).toHaveBeenCalled(),await new Promise(e=>setTimeout(e,1500)),expect(t).toHaveBeenCalledWith(1),t.mockRestore()})}),describe("getQueueStats",()=>{it("should return correct queue statistics",async()=>{n.getWaitingCount.mockResolvedValue(5),n.getDelayedCount.mockResolvedValue(2),n.getActiveCount.mockResolvedValue(3),p.listDevices.mockResolvedValue([{udid:"device1"},{udid:"device2"}]),u.getDeviceConfig.mockResolvedValueOnce({deviceId:"device1",status:"active",availableAmount:1e6}).mockResolvedValueOnce({deviceId:"device2",status:"active",availableAmount:1e6}),l.isLocked.mockResolvedValueOnce(!1).mockResolvedValueOnce(!1),v.processingJobs.add(1);const e=await v.getQueueStats();expect(e).toMatchObject({activeDevices:2,processingJobs:1,queue:{waiting:5,delayed:2,active:3,total:10}}),v.processingJobs.clear()})}),describe("triggerPickJobs",()=>{it("should call pickAndProcessJobs with specified count",async()=>{const e=jest.spyOn(v,"pickAndProcessJobs").mockResolvedValue(void 0);await v.triggerPickJobs(5),expect(e).toHaveBeenCalledWith(5),e.mockRestore()})})});