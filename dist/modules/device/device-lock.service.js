"use strict";var t,e=this&&this.t||function(t,e,i,r){var c,s=arguments.length,o=3>s?e:null===r?r=Object.getOwnPropertyDescriptor(e,i):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,i,r);else for(var a=t.length-1;a>=0;a--)(c=t[a])&&(o=(3>s?c(o):s>3?c(e,i,o):c(e,i))||o);return s>3&&o&&Object.defineProperty(e,i,o),o},i=this&&this.i||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)};Object.defineProperty(exports,"o",{value:!0}),exports.DeviceLockService=void 0;const r=require("@nestjs/common"),c=require("../../common/services/redis.service"),s=require("crypto"),o='\nif redis.call("GET", KEYS[1]) == ARGV[1] then\n  redis.call("DEL", KEYS[2])\n  return redis.call("DEL", KEYS[1])\nelse\n  return 0\nend\n';let a=t=class{constructor(e){this.redisService=e,this.logger=new r.Logger(t.name),this.REDIS_LOCK_PREFIX="device:lock:",this.DEFAULT_LOCK_TTL=6e5}async acquireLock(t,e,i,r=this.DEFAULT_LOCK_TTL){try{const c=`${this.REDIS_LOCK_PREFIX}${t}`,o=`${this.REDIS_LOCK_PREFIX}${t}:meta`,a=(0,s.randomUUID)(),n=Math.ceil(r/1e3),h=await this.redisService.getClient();if("OK"===await h.set(c,a,"EX",n,"NX")){const c={deviceId:t,lockType:e,lockedAt:Date.now(),lockedBy:i,ttl:r};return await this.redisService.setex(o,n,JSON.stringify(c)),this.logger.log(`Acquired ${e} lock for device ${t} (${i}) with lockId ${a}`),!0}return this.logger.warn(`Device ${t} is already locked, cannot acquire lock`),!1}catch(e){return this.logger.error(`Error acquiring lock for device ${t}: ${e.message}`),!1}}async releaseLock(t){try{const e=`${this.REDIS_LOCK_PREFIX}${t}`,i=`${this.REDIS_LOCK_PREFIX}${t}:meta`,r=await this.redisService.getClient(),c=await r.get(e);if(!c)return await this.redisService.del(i),this.logger.debug(`Device ${t} is not locked, nothing to release`),void 0;1===await r.eval(o,2,e,i,c)?this.logger.log(`Released lock for device ${t} (lockId: ${c})`):this.logger.warn(`Lock for device ${t} was already released or changed (expected lockId: ${c})`)}catch(e){this.logger.error(`Error releasing lock for device ${t}: ${e.message}`,e.stack)}}async getLock(t){try{const e=`${this.REDIS_LOCK_PREFIX}${t}`,i=await this.redisService.get(e);if(!i)return null;const r=`${this.REDIS_LOCK_PREFIX}${t}:meta`,c=await this.redisService.get(r);return c?{...JSON.parse(c),lockId:i}:{deviceId:t,lockType:"transfer",lockedAt:Date.now(),lockedBy:"unknown",ttl:this.DEFAULT_LOCK_TTL,lockId:i}}catch(e){return this.logger.error(`Error getting lock for device ${t}: ${e.message}`),null}}async isLocked(t,e){try{const i=`${this.REDIS_LOCK_PREFIX}${t}`;if(!await this.redisService.exists(i))return!1;const r=await this.getLock(t);return!(!r||e&&r.lockType===e)}catch(e){return this.logger.error(`Error checking lock status for device ${t}: ${e.message}`),!1}}async extendLock(t,e){try{if(!await this.getLock(t))return!1;const i=`${this.REDIS_LOCK_PREFIX}${t}`,r=`${this.REDIS_LOCK_PREFIX}${t}:meta`,c=await this.redisService.getClient(),s=await c.ttl(i);if(0>=s)return!1;const o=Math.ceil((1e3*s+e)/1e3);return 1===await c.expire(i,o)&&(await this.redisService.expire(r,o),this.logger.log(`Extended lock for device ${t} by ${e}ms`),!0)}catch(e){return this.logger.error(`Error extending lock for device ${t}: ${e.message}`),!1}}async releaseLockByType(t,e){try{const i=await this.getLock(t);if(!i)return!1;if(i.lockType!==e)return!1;const r=`${this.REDIS_LOCK_PREFIX}${t}`,c=`${this.REDIS_LOCK_PREFIX}${t}:meta`;return await this.redisService.del(r),await this.redisService.del(c),this.logger.log(`Force released ${e} lock for device ${t}`),!0}catch(i){return this.logger.error(`Error releasing ${e} lock for device ${t}: ${i.message}`),!1}}};exports.DeviceLockService=a,exports.DeviceLockService=a=t=e([(0,r.Injectable)(),i("design:paramtypes",[c.RedisService])],a);