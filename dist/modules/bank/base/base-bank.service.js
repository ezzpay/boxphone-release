"use strict";var t,e=this&&this.t||function(t,e,i,a){var s,r=arguments.length,n=3>r?e:null===a?a=Object.getOwnPropertyDescriptor(e,i):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)n=Reflect.decorate(t,e,i,a);else for(var c=t.length-1;c>=0;c--)(s=t[c])&&(n=(3>r?s(n):r>3?s(e,i,n):s(e,i))||n);return r>3&&n&&Object.defineProperty(e,i,n),n},i=this&&this.i||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)},a=this&&this.o||function(t,e){return function(i,a){e(i,a,t)}};Object.defineProperty(exports,"h",{value:!0}),exports.BaseBankService=void 0;const s=require("@nestjs/common"),r=require("../../device/device.service"),n=require("../../../common/modules/websocket/constants/websocket"),c=require("../../../common/utils/time"),o=require("fs"),h=require("fs/promises"),l=require("path"),u=require("../constants/bill"),$=require("../../ocr/ocr");let p=t=class{constructor(e,i){this.wsService=e,this.deviceService=i,this.baseTransactionFolderPath="C:/EzpData",this.logger=new s.Logger(this.constructor.name),t.createTransactionFolder(this.baseTransactionFolderPath,this.logger)}static createTransactionFolder(e,i){if(!t.folderCreated){if(t.folderCreationInProgress){let i=0;const a=10;for(;t.folderCreationInProgress&&a>i;){i++;const t=Date.now();for(;10>Date.now()-t;);}if(t.folderCreated||(0,o.existsSync)(e))return t.folderCreated=!0,void 0}try{t.folderCreationInProgress=!0,(0,o.existsSync)(e)?i.debug("Base folder already exists: "+e):((0,o.mkdirSync)(e,{recursive:!0}),i.log("Created base folder: "+e)),t.folderCreated=!0}catch(a){"EEXIST"!==a.code?i.error(`Failed to create base folder ${e}: ${a.message}`):(t.folderCreated=!0,i.debug("Base folder already exists (created by another process): "+e))}finally{t.folderCreationInProgress=!1}}}getBankCode(){return this.BANK_CODE}async launchApp(t,e=3){for(let i=1;e>=i;i++)try{return 1===i?this.logger.log(`Launching ${this.BANK_CODE} app on device ${t}`):this.logger.log(`Retrying launch ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e})`),await this.wsService.launchApp(t,this.BUNDLE_ID),await(0,c.sleep)(1e4),i>1?this.logger.log(`${this.BANK_CODE} app launched successfully on device ${t} after ${i} attempt(s)`):this.logger.log(`${this.BANK_CODE} app launched successfully on device ${t}`),void 0}catch(a){if(!(a instanceof Error&&a.message.includes("timeout")))throw this.logger.error(`Error launching ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}): ${a.message}`),a;if(i>=e)throw this.logger.error(`Error launching ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}): ${a.message}`),a;{const a=1e3*Math.pow(2,i);this.logger.warn(`WebSocket timeout when launching ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}). Retrying in ${a}ms...`),await(0,c.sleep)(a)}}}async killApp(t,e=2){for(let i=1;e>=i;i++)try{return 1===i?this.logger.log(`Killing ${this.BANK_CODE} app on device ${t}`):this.logger.log(`Retrying kill ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e})`),await this.wsService.killApp(t,this.BUNDLE_ID),await(0,c.sleep)(3e3),i>1?this.logger.log(`${this.BANK_CODE} app killed successfully on device ${t} after ${i} attempt(s)`):this.logger.log(`${this.BANK_CODE} app killed successfully on device ${t}`),void 0}catch(a){if(!(a instanceof Error&&a.message.includes("timeout")))throw this.logger.error(`Error killing ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}): ${a.message}`),a;if(i>=e)throw this.logger.error(`Error killing ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}): ${a.message}`),a;{const a=1e3*Math.pow(2,i-1);this.logger.warn(`WebSocket timeout when killing ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}). Retrying in ${a}ms...`),await(0,c.sleep)(a)}}}async clickWithTransition(t,e,i,a,s=""){await this.wsService.click(t,e,i,.2),s&&this.logger.log(s),await(0,c.sleep)(a)}async captureScreen(t,e){this.logger.log(`Capturing screen on device ${t} with folderPath: ${e.folderPath}`);const i=`${this.baseTransactionFolderPath}/${e.folderPath}`;await(0,h.mkdir)(i,{recursive:!0}),await(0,c.sleep)(1e3),await this.wsService.captureScreen(t,{...e,folderPath:i}),await(0,c.sleep)(5e3)}async getBillImage(t){try{const e=(0,l.join)(this.baseTransactionFolderPath,t),i=(await(0,h.readdir)(e))[0];if(!i)return this.logger.warn("No image file found in folder: "+t),null;const a=(0,l.join)(e,i),s=(await(0,h.readFile)(a)).toString("base64"),r=i.toLowerCase().substring(i.lastIndexOf("."));return`data:${(0,u.getMimeType)(r)};base64,${s}`}catch(e){throw this.logger.error(`Error loading image from folder ${t}: ${e.message}`),e}}async analyzeTransferBill(t){const e=await this.getBillImage(t.withdrawalCode);try{if(!e)return{raw:null,analyzedStatus:"na"};const t=await(0,$.ocrBill)(e);return{raw:e,analyzedStatus:(0,$.analyzeBill)(t.parsedText).analyzedStatus}}catch(t){return this.logger.error("Error analyzing transfer bill: "+t.message),{raw:e,analyzedStatus:"na"}}}};exports.BaseBankService=p,p.folderCreationInProgress=!1,p.folderCreated=!1,exports.BaseBankService=p=t=e([(0,s.Injectable)(),a(0,(0,s.Inject)(n.WEBSOCKET_SERVICE)),i("design:paramtypes",[Object,r.DeviceService])],p);