"use strict";var t,e=this&&this.t||function(t,e,i,a){var r,s=arguments.length,n=3>s?e:null===a?a=Object.getOwnPropertyDescriptor(e,i):a;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)n=Reflect.decorate(t,e,i,a);else for(var o=t.length-1;o>=0;o--)(r=t[o])&&(n=(3>s?r(n):s>3?r(e,i,n):r(e,i))||n);return s>3&&n&&Object.defineProperty(e,i,n),n},i=this&&this.i||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)},a=this&&this.o||function(t,e){return function(i,a){e(i,a,t)}};Object.defineProperty(exports,"l",{value:!0}),exports.BaseBankService=void 0;const r=require("@nestjs/common"),s=require("../../device/device.service"),n=require("../../../common/modules/websocket/constants/websocket"),o=require("../../../common/utils/time"),c=require("fs"),l=require("fs/promises"),h=require("path"),u=require("../constants/bill"),$=require("../../ocr/ocr");let f=t=class{constructor(e,i){this.wsService=e,this.deviceService=i,this.baseTransactionFolderPath="C:/EzpData",this.logger=new r.Logger(this.constructor.name),t.createTransactionFolder(this.baseTransactionFolderPath,this.logger)}static createTransactionFolder(e,i){if(!t.folderCreated){if(t.folderCreationInProgress){let i=0;const a=10;for(;t.folderCreationInProgress&&a>i;){i++;const t=Date.now();for(;10>Date.now()-t;);}if(t.folderCreated||(0,c.existsSync)(e))return t.folderCreated=!0,void 0}try{t.folderCreationInProgress=!0,(0,c.existsSync)(e)?i.debug("Base folder already exists: "+e):((0,c.mkdirSync)(e,{recursive:!0}),i.log("Created base folder: "+e)),t.folderCreated=!0}catch(a){"EEXIST"!==a.code?i.error(`Failed to create base folder ${e}: ${a.message}`):(t.folderCreated=!0,i.debug("Base folder already exists (created by another process): "+e))}finally{t.folderCreationInProgress=!1}}}getBankCode(){return this.BANK_CODE}async launchApp(t,e=3){for(let i=1;e>=i;i++)try{return 1===i?this.logger.log(`Launching ${this.BANK_CODE} app on device ${t}`):this.logger.log(`Retrying launch ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e})`),await this.wsService.launchApp(t,this.BUNDLE_ID),await(0,o.sleep)(1e4),i>1?this.logger.log(`${this.BANK_CODE} app launched successfully on device ${t} after ${i} attempt(s)`):this.logger.log(`${this.BANK_CODE} app launched successfully on device ${t}`),void 0}catch(a){if(!(a instanceof Error&&a.message.includes("timeout")))throw this.logger.error(`Error launching ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}): ${a.message}`),a;if(i>=e)throw this.logger.error(`Error launching ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}): ${a.message}`),a;{const a=1e3*Math.pow(2,i);this.logger.warn(`WebSocket timeout when launching ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}). Retrying in ${a}ms...`),await(0,o.sleep)(a)}}}async killApp(t,e=2){for(let i=1;e>=i;i++)try{return 1===i?this.logger.log(`Killing ${this.BANK_CODE} app on device ${t}`):this.logger.log(`Retrying kill ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e})`),await this.wsService.killApp(t,this.BUNDLE_ID),await(0,o.sleep)(3e3),i>1?this.logger.log(`${this.BANK_CODE} app killed successfully on device ${t} after ${i} attempt(s)`):this.logger.log(`${this.BANK_CODE} app killed successfully on device ${t}`),void 0}catch(a){if(!(a instanceof Error&&a.message.includes("timeout")))throw this.logger.error(`Error killing ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}): ${a.message}`),a;if(i>=e)throw this.logger.error(`Error killing ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}): ${a.message}`),a;{const a=1e3*Math.pow(2,i-1);this.logger.warn(`WebSocket timeout when killing ${this.BANK_CODE} app on device ${t} (attempt ${i}/${e}). Retrying in ${a}ms...`),await(0,o.sleep)(a)}}}async clickWithTransition(t,e,i,a,r=""){await this.wsService.click(t,e,i,.2),r&&this.logger.log(r),await(0,o.sleep)(a)}async captureScreen(t,e){this.logger.log(`Capturing screen on device ${t} with folderPath: ${e.folderPath}`);const i=`${this.baseTransactionFolderPath}/${e.folderPath}`;await(0,l.mkdir)(i,{recursive:!0}),await(0,o.sleep)(1e3),await this.wsService.captureScreen(t,{...e,folderPath:i}),await(0,o.sleep)(5e3)}async getBillImage(t){try{const e=(0,h.join)(this.baseTransactionFolderPath,t),i=(await(0,l.readdir)(e))[0];if(!i)return this.logger.warn("No image file found in folder: "+t),null;const a=(0,h.join)(e,i),r=(await(0,l.readFile)(a)).toString("base64"),s=i.toLowerCase().substring(i.lastIndexOf("."));return`data:${(0,u.getMimeType)(s)};base64,${r}`}catch(e){throw this.logger.error(`Error loading image from folder ${t}: ${e.message}`),e}}async getBillImagePath(t){try{const e=(0,h.join)(this.baseTransactionFolderPath,t),i=(await(0,l.readdir)(e))[0];return i?(0,h.join)(e,i):(this.logger.warn("No image file found in folder: "+t),null)}catch(e){return this.logger.error(`Error loading image from folder ${t}: ${e.message}`),null}}async analyzeTransferBill(t){const e=await this.getBillImagePath(t.withdrawalCode);try{if(!e)return{rawPath:null,analyzedStatus:"na"};const t=await(0,$.ocrBillPro)(e);return t?{rawPath:e,analyzedStatus:(0,$.analyzeBill)(t.parsedText).analyzedStatus}:{rawPath:e,analyzedStatus:"na"}}catch(t){return this.logger.error("Error analyzing transfer bill: "+t.message),{rawPath:e,analyzedStatus:"na"}}}};exports.BaseBankService=f,f.folderCreationInProgress=!1,f.folderCreated=!1,exports.BaseBankService=f=t=e([(0,r.Injectable)(),a(0,(0,r.Inject)(n.WEBSOCKET_SERVICE)),i("design:paramtypes",[Object,s.DeviceService])],f);