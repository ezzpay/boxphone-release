"use strict";var t,e=this&&this.t||function(t,e,i,r){var s,n=arguments.length,a=3>n?e:null===r?r=Object.getOwnPropertyDescriptor(e,i):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(t,e,i,r);else for(var o=t.length-1;o>=0;o--)(s=t[o])&&(a=(3>n?s(a):n>3?s(e,i,a):s(e,i))||a);return n>3&&a&&Object.defineProperty(e,i,a),a},i=this&&this.i||function(t,e){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(t,e)};Object.defineProperty(exports,"o",{value:!0}),exports.BankService=void 0;const r=require("@nestjs/common"),s=require("./acb.service"),n=require("./pg.service"),a=require("../device/device.service"),o=require("../hcbox/hcbox.service"),c=require("./session-management.service"),h=require("../device/device-lock.service"),l=require("../../common/utils/time");let f=t=class{constructor(e,i,s,n,a,o){this.acbService=e,this.pgService=i,this.deviceService=s,this.hcBoxService=n,this.sessionManagement=a,this.deviceLock=o,this.logger=new r.Logger(t.name),this.bankServices=new Map,this.registerBankService(this.acbService),this.registerBankService(this.pgService)}registerBankService(t){const e=t.getBankCode().toUpperCase();this.bankServices.set(e,t),this.logger.log("Registered bank service: "+e)}getBankService(t){const e=this.bankServices.get(t.toUpperCase());return e||this.logger.warn("Bank service not found for bank code: "+t),e||null}getSupportedBanks(){return Array.from(this.bankServices.keys())}async login(t,e,i=!1){if(await this.deviceLock.isLocked(e)&&!i){const t=await this.deviceLock.getLock(e);throw Error(`Device ${e} is currently locked by ${t?.lockType} (${t?.lockedBy}). Cannot login.`)}const r=`login:${t}:${e}:${Date.now()}`;if(!await this.deviceLock.acquireLock(e,"login",r,3e5))throw Error("Failed to acquire lock for device "+e);try{await this.sessionManagement.markLoggingIn(e,t);const i=this.getBankService(t);if(!i)throw Error("Bank service not found for bank code: "+t);this.logger.log(`Logging in to ${t} on device ${e}`),await i.login(e),await this.sessionManagement.recordLogin(e,t),this.logger.log(`Successfully logged in to ${t} on device ${e}`)}catch(i){throw await this.sessionManagement.clearSession(e,t),i}finally{await this.deviceLock.releaseLock(e)}}async loginAllActiveBanks(){try{const t=(await this.deviceService.listDevices()).filter(t=>"active"===t.status&&t.bankCode);if(0===t.length)return this.logger.warn("No active devices found to login"),void 0;this.logger.log(`Logging in to ${t.length} active device(s)`);for(const e of t){const t=e.udid;try{await this.deviceLock.releaseLockByType(t,"transfer")}catch(e){this.logger.warn(`Failed to release transfer lock for device ${t}: ${e.message}`)}}const e=[];for(const i of t){const t=i.bankCode.toUpperCase(),r=i.udid;e.push(this.login(t,r,!0).catch(e=>{this.logger.error(`Failed to login ${t} on device ${r}: ${e.message}`)}))}await Promise.allSettled(e),this.logger.log("Completed login process for all active banks")}catch(t){throw this.logger.error("Error logging in all active banks: "+t.message),t}}async executeTransfer(t,e,i,r=!1,s=2){const{withdrawalId:n}=t;let a=!1;if(!r){if(await this.deviceLock.isLocked(e)){const t=await this.deviceLock.getLock(e);return this.logger.warn(`Device ${e} is locked by ${t?.lockType} (${t?.lockedBy}). Cannot execute transfer.`),!1}const t=`withdraw:${n}:${e}`;if(a=await this.deviceLock.acquireLock(e,"transfer",t,6e5),!a)return this.logger.error("Failed to acquire transfer lock for device "+e),!1}try{if(!await this.sessionManagement.isSessionValid(e,i))return this.logger.warn(`Device ${e} does not have valid session for bank ${i}. Session may be expired or logging in.`),!1;const r=this.getBankService(i);if(!r)return this.logger.warn(`Bank ${i} not supported, using generic HcBoxService`),!1;for(let a=1;s>=a;a++)try{return a>1?this.logger.log(`Retrying transfer execution for withdrawal ${n} (attempt ${a}/${s})`):this.logger.log(`Executing transfer for bank: ${i}, withdrawal: ${n}`),await r.executeTransfer(t,e),!0}catch(t){if(!(t instanceof Error&&t.message.includes("timeout")))return this.logger.error(`Transfer execution failed for withdrawal ${n} (non-timeout error): ${t.message}`),!1;if(a>=s)return this.logger.error(`Transfer execution failed for withdrawal ${n} after ${s} attempts: ${t.message}`),!1;{const t=2e3*Math.pow(2,a-1);this.logger.warn(`Transfer execution timeout for withdrawal ${n} (attempt ${a}/${s}). Retrying in ${t}ms...`),await(0,l.sleep)(t)}}return!1}catch(t){return this.logger.error("Error executing transfer: "+t.message),!1}finally{!r&&a&&await this.deviceLock.releaseLock(e)}}async isSessionValid(t,e){return await this.sessionManagement.isSessionValid(t,e)}async getBillImage(t,e){const i=this.getBankService(t);return i?await i.getBillImage(e):(this.logger.warn(`Bank ${t} not supported, cannot get bill image`),null)}async analyzeTransferBill(t,e){const i=this.getBankService(t);return i?await i.analyzeTransferBill(e):(this.logger.warn(`Bank ${t} not supported, cannot analyze transfer bill`),null)}async refreshSessionIfNeeded(t,e){const i=await this.sessionManagement.getSession(t,e);if("logging_in"===i?.status)return!1;const r=await this.sessionManagement.needsRefresh(t,e),s=await this.sessionManagement.isSessionValid(t,e);if(!r&&s)return!1;if(await this.deviceLock.isLocked(t))return this.logger.warn(`Cannot refresh session for device ${t} - device is locked`),!1;try{return s?this.logger.log(`Refreshing session for device ${t}, bank ${e}`):this.logger.log(`Session expired or missing for device ${t}, bank ${e}. Retrying login...`),await this.login(e,t),!0}catch(e){return this.logger.error(`Failed to refresh session for device ${t}: ${e.message}`),!1}}};exports.BankService=f,exports.BankService=f=t=e([(0,r.Injectable)(),i("design:paramtypes",[s.AcbService,n.PgService,a.DeviceService,o.HcBoxService,c.SessionManagementService,h.DeviceLockService])],f);